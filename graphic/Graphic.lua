---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Warren.
--- DateTime: 2021/9/4 12:33
---

ClassTable = {}

Class = (function()
    -- 源元表
    local originMetatable = {
        __newindex = function(table, key, value)
            rawset(table, key, value);
        end
    }
    -- 元类
    local originClass = setmetatable({}, {
        __newindex = function(table, key, value)
            rawset(table, key, value);
        end
    })
    -- 元对象
    originClass["Object"] = {
        className = "Object",
        functionTable = {
            __index = function()
            end,
            __newindex = function(table, key, value)
                print("table = ", table);
                print("key = ", key);
                print("value = ", value);
                if value == nil then
                    error("赋值不能为nil");
                end
                if table[key] ~= nil and type(value) ~= type(table[key]) then
                    error('key:' .. key .. "赋值不能重复" .. type(value) .. "~=" .. type(table[key]));
                end
                if table[key] ~= nil then
                    local temp = table;
                    while temp ~= nil do
                        if rawget(temp, key) ~= nil then
                            rawset(temp, key, value);
                            return ;
                        end
                        temp = temp.super;
                    end
                end
                rawset(table, key, value);
            end,
            __call = function()
            end,
            __tostring = function()
            end
        },
        superClass = nil
    }
    -- 元构造方法
    local function ConstructClass(name, func, super)
        if ClassTable[name] ~= nil then
            print("请检查你的代码")
            print("不要重复定义类型")
            return
        end
        ClassTable[name] = name
        super = (super or { originClass = originClass["Object"] }).originClass
        local object = {}
        func(object)
        originClass[name] = {
            className = name,
            functionTable = object,
            superClass = super
        }
        if object.static == true then
            _G[name] = originClass[name].functionTable
        else
            local classList = { originClass[name] }
            while super ~= nil do
                classList[#classList + 1] = super
                super = super.superClass
            end
            local str = {}
            for i = 1, #classList do
                str[#str + 1] = string.format("local %s = {super = nil, __index = nil, __newindex = nil, __call = nil, __tostring = nil,", classList[i].className)
                for key, _ in pairs(classList[i].functionTable) do
                    str[#str + 1] = string.format("%s = originClass['%s'].functionTable.%s,", key, classList[i].className, key);
                end
                str[#str + 1] = "};"
            end
            for i = 1, #classList do
                if i ~= 1 then
                    str[#str + 1] = string.format("%s.__call = %s.construct or function() end;", classList[i].className, classList[i - 1].className);
                end
                if i ~= #classList then
                    if i ~= #classList - 1 then
                        str[#str + 1] = string.format("%s.super = %s;", classList[i].className, classList[i + 1].className);
                    end
                    str[#str + 1] = string.format("%s.__index = %s;", classList[i].className, classList[i].className) .. string.format("%s.__newindex = Object.__newindex;", classList[i].className) .. string.format("setmetatable(%s, %s);", classList[i].className, classList[i + 1].className);
                end
            end
            str[#str + 1] = string.format("return %s;", name);
            originClass[name].origin = load(table.concat(str), "", "t", {
                rawset = rawset,
                error = error,
                type = type,
                rawget = rawget,
                getmetatable = getmetatable,
                setmetatable = setmetatable,
                originClass = originClass
            })
            local pool = {};
            _G[name] = setmetatable({
                originClass = originClass[name],
            }, {
                __call = function(self, ...)
                    local object;
                    if #pool ~= 0 then
                        object = table.remove(pool, #pool);
                    else
                        object = self.originClass.origin();
                    end
                    object(...);
                    return object;
                end
            })
        end
    end
    return ConstructClass
end)()

GraphicsTable = {};
Class("Graphics", function(Graphics)
    -- 构造器
    function Graphics:construct(graphicsName)
        if graphicsName == nil or graphicsName == "" then
            error("定时器类名称不能为空");
        end
        if GraphicsTable[graphicsName] ~= nil then
            error("无法重复定义" .. graphicsName);
        end
        self.boxes = {};
        self.name = graphicsName;
        GraphicsTable[graphicsName] = self;
    end
    -- 自建函数
    function Graphics:create()
        return self;
    end
    -- 绘图
    function Graphics:drawGraphics(x, y, image, pixel, red, green, blue, alpha)
        if (image == nil) then
            error("请输入图形元素表");
        end
        local x = x or 0;
        local y = y or 0;
        local pixel = pixel or 1;
        for i = 1, #image, 5 do
            local box = UI.Box.Create();
            if box == nil then
                print("超过box限制，绘画失败");
                return ;
            end
            box:Set({
                x = x + image[i] * pixel,
                y = y + image[i + 1] * pixel,
                width = image[i + 2] * pixel,
                height = image[i + 3] * pixel,
                r = red or (image[i + 4] & 0xff0000) >> 16,
                g = green or (image[i + 4] & 0xff00) >> 8,
                b = blue or (image[i + 4] & 0xff),
                a = alpha or (image[i + 4] & 0xff000000) >> 24
            });
            table.insert(self.boxes, box);
        end
    end
    -- 销毁
    function Graphics:destroy()
        GraphicsTable[self.name] = nil;
    end

end);

-- 从三代技能表里复制后面的值 变量名自己定义 我这里定义为 picture
picture = {32,104,2,12,-6697729,34,98,2,22,-6697729,36,96,2,26,-6697729,38,94,2,32,-6697729,40,90,2,36,-6697729,42,88,2,38,-6697729,44,86,2,44,-6697729,46,84,2,46,-6697729,48,20,2,6,-6697729,48,82,2,48,-6697729,50,18,2,14,-6697729,50,78,2,50,-6697729,52,18,2,22,-6697729,52,74,2,54,-6697729,54,18,2,42,-6697729,54,70,2,56,-6697729,56,16,8,110,-6697729,64,14,4,106,-6697729,64,122,2,2,-6697729,68,14,4,104,-6697729,72,12,2,104,-6697729,74,12,2,102,-6697729,76,12,2,100,-6697729,78,12,2,96,-6697729,80,12,2,94,-6697729,82,12,2,92,-6697729,84,14,2,90,-6697729,86,18,2,86,-6697729,88,26,2,74,-6697729,90,42,2,58,-6697729,92,50,2,50,-6697729,94,60,2,36,-6697729,96,64,2,30,-6697729,98,66,2,26,-6697729,100,68,2,4,-6697729,100,76,2,14,-6697729,102,84,2,2,-6697729,}
-- 定义一个绘图器 我这里定义为g
local g = Graphics("g");
-- 调用绘图器 g的 drawGraphics方法 传入参数
-- (图像出现的x坐标, 图像出现的y坐标, 图像数据, 每个像素的大小, R(RGB颜色中R的占比，最大255), G(RGB颜色中G的占比，最大255), B(RGB颜色中B的占比，最大255))
g:drawGraphics(100, 100, picture, 1, nil, nil, nil);
-- 销毁绘图器
-- g:destroy();
